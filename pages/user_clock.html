

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
		
		<title></title>

		<link rel="stylesheet" type="text/css" href="../css/user.css" />
		<script type="text/javascript" src="../js/config.js"></script>
		<!-- 引入jQuery.js -->
		<script type="text/javascript" src="../js/jquery.min.js"></script>
	
		<!-- 画板 -->
		<div style="position: relative;height: 100%;width: 100%;">
			<!-- <div id="bot"> -->
			<!-- <div id="draw-title" style="display: ;">
					<ul>
						<li style="float: left;">量表名称:画钟测验({{CDT-3}})</li>
						<li style="margin-left: 90%;">完成</li>
					</ul>
				</div> -->
		
				<!-- <div id="draw-tools">
					<ul id="tools-list">
						<li id="tools-title">工具栏</li>
						<li>
							<hr />
						</li>
						<li id="tools-pencil"> <img src="../svg/pen.svg" id="pencil-img" alt="1" />画笔
							<div id="pen-color">
								<ul id="color-lisst">
									<li style="background-color: red;" onclick="getPen('red')"></li>
									<li style="background-color: blueviolet;" onclick="getPen('blueviolet')"></li>
									<li style="background-color: black;" onclick="getPen('black')"></li>
									<li style="background-color: yellow;" onclick="getPen('yellow')"></li>
									<li style="background-color: lightskyblue;" onclick="getPen('lightskyblue')"></li>
								</ul>
							</div>
						</li>
						<li id="tools-cancle" onclick="cancle_pen()"><img src="../svg/eraser.svg" />撤销</li>
						<li id="tools-cancle" onclick="drawAgain()"><img src="../svg/eraser.svg" />重画</li>
					</ul>
				</div> -->
				<!-- 悬浮工具栏 -->
				<div id="suspend" style="position: absolute;z-index: 15;width: 40px;height: 40px;background-color: #2AC845;bottom: 30px;left: 20px;"></div>
				<!-- 画板 -->
				<canvas id="myCanvas" style="background-color: #C0C0C0;position: fixed;z-index: 10;top: 0;bottom: 0;margin: auto 0;">
				</canvas>
			<!-- </div> -->
		</div>


	<script>
		// document.getElementById('pencil-img').ontouchstart = function() {
		// 	if (this.alt == 1) {
		// 		$("#pen-color").fadeIn(1000);
		// 		this.alt = 0;
		// 	} else {
		// 		$("#pen-color").fadeOut(1000);
		// 		this.alt = 1;
		// 	}
		// }
	</script>
	<script>
		/**
		 * ！！！！要设置为在画布中有记录之后才能发送消息！！！！
		 */
		var bot = document.getElementById('myCanvas'); //画布div
		bot.height = window.screen.height;
		bot.width = window.screen.width;
		//alert(bot.width+"||"+bot.height)
		var ttt = document.getElementById('draw-tools');
		//alert(ttt.style.width)
		//alert(bot.height+","+bot.width)
		var myCanvas = document.getElementById('myCanvas', 1); //创建画布
		var x, y, x1, y1; //记录坐标
		function kkk() {
			alert(JSON.stringify(bot.getBoundingClientRect()))
			return
		}
		//kkk()
		// var x0 = bot.getBoundingClientRect().x,
		// 	y0 = bot.getBoundingClientRect().y; //画板坐标偏移量
		var x0 = 0,
			y0 = 0;
		var flag = 0;
		var context = myCanvas.getContext('2d'); //获取上下文
		var isMouseDown = false; //判断鼠标是否按下，默认没有
		var isMove = false; //判断有没有移动
		var dataURL; //画图内容
		var imgStack = []; //图像栈
		var flag_img = 0;
		var pen_color = 'red';
		var pen_width = 2;
		let dt; //
		window.onload = function() {
			bot.ontouchstart = mouseDownAction;
			bot.ontouchmove = mouseMoveAction;
			bot.ontouchend = mouseUpAction;

			// bot.onmousedown = mouseDownAction;
			// bot.onmousemove = mouseMoveAction;
			// bot.onmouseup = mouseUpAction;
		}



		/**
		 * 选择画笔颜色
		 */
		function getPen(colour) {
			$("#pen-color").fadeOut(600, () => {
				document.getElementById('pencil-img').alt = 1;
				console.log("**===")
			});
			pen_color = colour + ""; //线条粗细
			pen_width = 2; //线条颜色
		}
		/**
		 * 撤回
		 */
		function cancle_pen() {
			if (dataURL == imgStack[imgStack.length - 1])
				imgStack.pop()
			dataURL = imgStack[imgStack.length - 1];
			bot.height = bot.height;
			let img = new Image();
			img.src = dataURL;
			img.addEventListener('load', () => {
				sendMSG();
				context.drawImage(img, 0, 0)
			})
		}
		/**
		 * 重画
		 */
		function drawAgain() {
			bot.height = bot.height;
			//console.log(dataURL)
			dataURL = myCanvas.toDataURL('image/webp');
			imgStack.push(dataURL);
			sendMSG(dataURL);
		}
		/**
		 * 鼠标按下
		 */
		// setInterval(() => {
		// 		if (websocket.readyState == 1) {
		// 			sendMSG()
		// 		}
		
		// 	}, 0.2)
		window.ontouchstart = function(e){
				//alert(e.touches[0].pageX+"||"+e.touches[0].pageY)
			};
		function mouseDownAction(e) {
			
		
			isMouseDown = true;
			
			// x = e.offsetX;
			// y = e.offsetY;
			
			console.log("client:"+e.touches[0].clientX+"||"+e.touches[0].clientY);
			console.log("page:"+e.touches[0].pageX+"||"+e.touches[0].pageY);
			console.log("screen:"+e.touches[0].screenX+"||"+e.touches[0].screenY);
			console.log(window.screen.width+"=="+window.screen.height)
			
	
			// alert("page:"+e.touches[0].pageX+"||"+e.touches[0].pageY);
			// alert("screen:"+e.touches[0].screenX+"||"+e.touches[0].screenY);
			// alert(window.screen.width+"=="+window.screen.height)

			x = e.touches[0].pageX - x0;
			y = e.touches[0].pageY - y0;
			// if (e && e.stopPropagation)
			// 	//因此它支持W3C的stopPropagation()方法 
			// 	e.stopPropagation();
			// else
			// 	//否则，我们需要使用IE的方式来取消事件冒泡 
			// 	window.event.cancelBubble = true;
		}
		/**
		 * 鼠标开始移动
		 */
		function mouseMoveAction(e) {
			if (isMouseDown) {
				// x1 = e.offsetX;
				// y1 = e.offsetY;
				x1 = e.touches[0].pageX - x0;
				y1 = e.touches[0].pageY - y0;
				drowLine(x, y, x1, y1);
				flag++;
				if (flag == 10000)
					flag = 1;
				if (e && e.stopPropagation)
					//因此它支持W3C的stopPropagation()方法 
					e.stopPropagation();
				else
					//否则，我们需要使用IE的方式来取消事件冒泡 
					window.event.cancelBubble = true;
			}
		}
		/**
		 * 鼠标弹起来
		 */
		function mouseUpAction(e) {
			clearInterval(dt)
			isMouseDown = false;
			flag = 0;
			if (isMove) {
				imgStack.push(dataURL);
				isMove = false;
				dataURL = myCanvas.toDataURL('image/webp');
				sendMSG(dataURL);

			}
			if (e && e.stopPropagation)
				//因此它支持W3C的stopPropagation()方法 
				e.stopPropagation();
			else
				//否则，我们需要使用IE的方式来取消事件冒泡 
				window.event.cancelBubble = true;
		}
		/**
		 * 画线
		 */
		function drowLine(X, Y, X1, Y1) {
			//开启新的路径
			if (flag) {
				context.beginPath();
				if (X != X1 && Y != Y1) {
					isMove = true;
				}
			}
			context.lineWidth = pen_width; //线条粗细
			context.strokeStyle = pen_color; //线条颜色
			context.moveTo(X, Y); //画笔起点坐标
			context.lineTo(X1, Y1); //画笔终点坐标
			context.stroke(); //绘制
			if (flag != 0) {
				x = x1;
				y = y1;
			}
		}
		/**
		 * websocket连接
		 */
		var websocket = null;
		websocket = new WebSocket(config.wsURL + '/websocket/' + 124)
		websocket.binaryType = "arraybuffer"
		websocket.onopen = function(e) {
			console.log('建立连接')
			//websocket.binaryType = 'arraybuffer'	//传送arraybuffer字符串
		}
		websocket.onclose = function(e) {
			console.log('连接关闭')
		}
		websocket.onmessage = function(e) {
			console.log("有消息推送", e.data, '***');
		}
		websocket.onerror = function() {
			console.log('建立连接出错')
		}
		//窗口关闭
		window.onbeforeunload = function() {
			websocket.close();
		}

		function sendMSG(str) {
			//发送消息是截断处理
			//var str = da + '';
			//	console.log(dataURL)
			var strArr = [];
			//消息发送目标用户
			//var targetUsers = ['123'];
			if (str.length > 7000) {
				for (let i = 0, index = 0; i < str.length; index++, i += 7000) {
					strArr[index] = str.slice(i, i + 7000);
				}
			} else {
				strArr[0] = str;
			}
			for (let i = 0; i < strArr.length; i++) {
				let obj = {};
				//obj.targets = [1,2,3,4,5,6,7,8];
				obj.target = 11;
				obj.data = strArr[i];
				obj.incise = true;
				if (i == strArr.length - 1)
					obj.endIncise = true;
				websocket.send(JSON.stringify(obj));
			}
		}


		function sendT() {
			//let str = base64ToUint8Array(dataURL);
			//console.log(str)

		}

		function base64ToUint8Array(base64String) {
			const padding = '='.repeat((4 - base64String.length % 4) % 4);
			const base64 = (base64String + padding)
				.replace(/\-/g, '+')
				.replace(/_/g, '/');

			const rawData = window.atob(base64);
			const outputArray = new Uint8Array(rawData.length);

			for (let i = 0; i < rawData.length; ++i) {
				outputArray[i] = rawData.charCodeAt(i);
			}
			return outputArray;
		}

		function arrayBufferToBase64(buffer) {
			var binary = '';
			var bytes = new Uint8Array(buffer);
			var len = bytes.byteLength;
			for (var i = 0; i < len; i++) {
				binary += String.fromCharCode(bytes[i]);
			}
			return window.btoa(binary);
		}
	</script>

